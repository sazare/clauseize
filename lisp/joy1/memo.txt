¬、∨、∧、⇒、≡、(∀ x)、(∃ x)を関数として作って、(eval wff)で同じことができないか

・論理演算子の機能として、式の変形(CNF化)を記述できないか


2022/08/21 各ステップで関数を切り替えたいので、
 (let ((f1 (lambda (x) (list x)))) (apply f1 '(12)))
で一時的に関数定義をかえられる。

論理演算子の意味では実行することはないので、これでいけるのではないか、

((∀ x) (P x))だと(∀ x)が関数になる必要があるので、(∀ x (P x))と書くことにしたい。
{(∀ x)を関数として定義できないか??無理だろう}
では
(∀ (x y) (∨ (P x)(Q y)))
みたいにvarsを書けたほうがいいのでは?
今は
(∀ x (∀ y (∨ (P x)(Q y))))

(x y)にしたとき、bindingの処理がlistになる。
1変数のときは
(∀ x (P x))
と書きたいか?　これは
(∀ (x) (P x))
でいいのではないか。

(x y)のときのrename処理はどうか?

cccccccccccccccccccccccccc cccccccccccccccccccccccccc


steps
1. ⇒, ≡の変形
　{∀,∃,∨,∧,¬}
2. ¬の押し込み
3. literal化{¬削除、+,-導入}
　{∀,∃,∧,∨}
4. ∀xのDVCとskolem関数化。
　　∀変数に変数名を割り当て、scope中の変数を変名する。
　　varsのpathを管理する。
　　∃変数の函数名化と、pathを引数にしたform作成し、scope中の∃変数をformで置換。
  {∧、∨}
5. DeMorganにより∧-∨化する
6. ∧、∨を削除し、clause形式に整理する





